ğŸ“˜ psCLI Dispatcher â€” Help File [EN]

ğŸ§© Overview
The Dispatcher is the core component of psCLI. It is responsible for:

- discovering modules in the modules/ directory
- loading Python modules and external scripts
- resolving and managing aliases
- reading and generating module metadata
- executing modules via their entry points (run, main, cli)
- monitoring the modules directory for changes
- logging and error reporting

It allows commands like:
pscli echo Hello
pscli ls
pscli myscript

ğŸ“‚ Directory Structure
project_root/
â”‚
â”œâ”€â”€ modules/
â”‚   â”œâ”€â”€ echo.py
â”‚   â”œâ”€â”€ list.py
â”‚   â”œâ”€â”€ external.cmd
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ metadata/
â”‚   â”œâ”€â”€ echo.meta.json
â”‚   â”œâ”€â”€ external.meta.json
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ aliases.json
â””â”€â”€ dispatcher.py

Userâ€‘level files:
%USERPROFILE%/.polsoft/settings/psCLI.json   â† user aliases
%USERPROFILE%/.polsoft/log/pscCLI.log        â† log file (only if already exists)
%USERPROFILE%/.polsoft/error/psCLIerror.txt â† error log

---

âš™ï¸ Module Loading
Dispatcher supports two categories of modules:

1. Python modules (modules/*.py)
Loaded via importlib.import_module.
A Python module must expose at least one of:
- run(args)
- main(args)
- cli(args)
2. External scripts
Supported extensions:
.cmd, .exe, .bat, .ps1, .vbs, .reg

Dispatcher returns the script path; execution is 
handled externally (e.g., via subprocess).

---

ğŸ·ï¸ Alias System
Aliases can come from:

- aliases.json in the project root
- user settings: %USERPROFILE%/.polsoft/settings/psCLI.json
- module metadata (aliases field)
- manual registration via register_alias()
User aliases override repository aliases.

Example aliases.json:
{
  "aliases": {
    "e": "echo",
    "ls": "list"
  }
}

Example alias in module metadata:
{
  "name": "Echo",
  "aliases": ["e", "repeat"]
}

---

ğŸ§  Module Metadata
Dispatcher loads metadata in this order:

- get_meta() function in the module
- META, __meta__, or meta variable
- metadata/<module>.meta.json
- <module>.meta.json next to external scripts
- JSON embedded in .cmd comments
- autoâ€‘generated stub metadata

Example metadata:
{
  "name": "Echo",
  "description": "Prints text to console",
  "aliases": ["e"],
  "args": ["text"],
  "category": "utility"
}

---

ğŸ” Module Discovery
discover() scans the modules/ directory for files with extensions:
.py, .cmd, .exe, .bat, .ps1, .vbs, .reg

It returns a sorted list of module names.

---

ğŸ”„ Watcher (Automatic Module Reloading)
The dispatcher can monitor the modules/ directory:
start_watcher(callback, interval=1.0)

It detects:
- added modules
- removed modules
- modified modules

On change:
- metadata is refreshed
- callback is executed
- a system notification is attempted (Toast or PowerShell popup)

---

ğŸ“ User Settings
Stored at:
%USERPROFILE%/.polsoft/settings/psCLI.json

Example:
{
  "aliases": {
    "e": "echo",
    "ll": "list"
  }
}

---

ğŸ§° Key Dispatcher Methods
|  |  | 
| discover() |  | 
| load(name) |  | 
| resolve(cmd) |  | 
| register_alias(a, t) |  | 
| remove_alias(a) |  | 
| list_commands() |  | 
| get_metadata(name) |  | 
| print_module_help(name) |  | 
| start_watcher() |  | 
| stop_watcher() |  | 

---

ğŸ–¥ï¸ Module Help Display
Dispatcher uses metadata to print help:
print_module_help("echo")

If no metadata exists:
- prints module docstring
- or shows â€œNo help availableâ€

---

ğŸ§¨ Error Handling
Custom exceptions:
- DispatcherError
- ModuleLoadError
- CommandNotFoundError
- EntryPointError
Errors are logged to:
%USERPROFILE%/.polsoft/error/psCLIerror.txt

---

ğŸ“¦ Example Python Module
modules/echo.py:

META = {
    "name": "Echo",
    "description": "Prints text to console",
    "aliases": ["e"],
    "args": ["text"]
}

def run(args):
    print(" ".join(args))

---

ğŸ§ª Example Usage
> pscli e Hello world
Hello world

> pscli list
echo
list
external

---

ğŸ¯ Summary
The Dispatcher provides:
- dynamic module discovery
- Python + external script support
- alias management
- metadata loading and generation
- automatic module change detection
- logging and error handling
It is the command execution backbone of psCLI.

If you'd like, I can also:
- generate a short version for end users
- create a Markdown README
- produce a manâ€‘page style help
- generate a CLI --help output
Just tell me what format you prefer.

technical documentation

The Dispatcher is the central control unit (command bus) of the system. It is responsible for dynamically loading logic, routing command-line arguments to the appropriate functions, and managing shortcuts (aliases).1. Architecture and Core ResponsibilitiesThe system is built on a modular architecture, allowing for functionality expansion without modifying the main script core.Dynamic Discovery: The Dispatcher scans the modules/ directory for Python scripts.Alias Management: It allows users to create short handles for long commands (e.g., e instead of echo). Aliases are persisted in an aliases.json file.Error Isolation: Every module execution is wrapped in a try-except block, preventing a single module's crash from taking down the entire REPL environment.2. Key Methods and FunctionsMethodDescriptiondispatch(args)The primary processing engine. It accepts a list of arguments, checks if the first one is an alias, and then loads and executes the corresponding module.register_alias(alias, target)Registers a new shortcut for an existing command or path in memory.load_aliases(path)Imports alias definitions from a JSON file. If the file is missing, the system starts with an empty list.refresh_metadata()Scans all modules to update information about available commands and their descriptions (used for generating help menus).start_watcher()Launches a background thread to monitor file changes. This enables "hot-reloading" of code without restarting the application.

Method,Description
dispatch(args),"The primary processing engine. It accepts a list of arguments, checks if the first one is an alias, and then loads and executes the corresponding module."
"register_alias(alias, target)",Registers a new shortcut for an existing command or path in memory.
load_aliases(path),"Imports alias definitions from a JSON file. If the file is missing, the system starts with an empty list."
refresh_metadata(),Scans all modules to update information about available commands and their descriptions (used for generating help menus).
start_watcher(),"Launches a background thread to monitor file changes. This enables ""hot-reloading"" of code without restarting the application."

3. Operating Modes
A. Direct Mode (CLI)
The user triggers a command directly from the terminal: ./main.py module_name --options The Dispatcher loads the module, executes it, and immediately terminates the process.

B. Interactive Mode (REPL)
Triggered when no arguments are provided or when using the watch flag.

Displays the ps> prompt.
The Dispatcher stays in memory, which significantly speeds up execution as modules can be cached.
Supports built-in administrative commands like aliases add or exit.

C. Watch Mode (Observer)
The advanced developer mode. The Dispatcher tracks changes in the source files. If you modify a module's code, the Dispatcher displays a notification, and the next execution of that command will automatically use the updated version.

4. Logic Workflow
Initialization: The Dispatcher instance is created, and aliases.json configurations are loaded.

Input Parsing: The input string is broken down into an argument list (using shlex).
Alias Expansion: If args[0] is found in the alias table, it is replaced with the full target command.
Module Localization: The system looks for the file located at modules/{name}.py.
Execution: The run(args) function (or equivalent) inside the module is invoked.
Exit Handling: The exit code is returned to the operating system.

5. Extensibility
To add new functionality, simply create a new .py file in the modules/ folder. The Dispatcher will automatically detect it upon the next run orâ€”in Watch Modeâ€”immediately upon saving the file.
